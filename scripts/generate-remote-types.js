#!/usr/bin/env node

/**
 * Auto-generates TypeScript declarations for Module Federation remotes
 *
 * Usage: node scripts/generate-remote-types.js
 *
 * Reads: packages/cashapps-remote/src/federation.config.json
 * Outputs: packages/crm-host/src/remotes.d.ts
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const ROOT = path.join(__dirname, '..')

const REMOTES_CONFIG = {
  cashappsRemote: {
    configPath: 'packages/cashapps-remote/src/federation.config.json',
    srcPath: 'packages/cashapps-remote/src',
  },
}

const OUTPUT_PATH = 'packages/crm-host/src/remotes.d.ts'

function extractExportsFromFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8')
  const exports = []

  const defaultExportMatch = content.match(/export\s+default\s+(?:function\s+)?(\w+)/)
  if (defaultExportMatch) {
    exports.push({ name: defaultExportMatch[1], isDefault: true })
  }

  const namedExportMatches = content.matchAll(/export\s+(?:const|function|interface|type|class)\s+(\w+)/g)
  for (const match of namedExportMatches) {
    exports.push({ name: match[1], isDefault: false })
  }

  return exports
}

function generateTypeForExpose(remoteName, exposeName, exposePath, srcPath) {
  const fullPath = path.join(ROOT, srcPath, exposePath.replace('./', ''))

  let actualPath = fullPath
  if (!fs.existsSync(actualPath)) {
    if (fs.existsSync(actualPath + '.tsx')) actualPath = actualPath + '.tsx'
    else if (fs.existsSync(actualPath + '.ts')) actualPath = actualPath + '.ts'
    else if (fs.existsSync(path.join(actualPath, 'index.tsx'))) actualPath = path.join(actualPath, 'index.tsx')
    else if (fs.existsSync(path.join(actualPath, 'index.ts'))) actualPath = path.join(actualPath, 'index.ts')
  }

  if (!fs.existsSync(actualPath)) {
    console.warn(`Warning: Could not find file for ${exposeName}: ${fullPath}`)
    return null
  }

  const exports = extractExportsFromFile(actualPath)
  const moduleName = `${remoteName}/${exposeName.replace('./', '')}`

  let declaration = `declare module '${moduleName}' {\n`

  const isComponent = actualPath.endsWith('.tsx') ||
    fs.readFileSync(actualPath, 'utf-8').includes('React')

  const defaultExport = exports.find(e => e.isDefault)
  if (defaultExport) {
    if (isComponent) {
      declaration += `  const ${defaultExport.name}: React.ComponentType<any>\n`
      declaration += `  export default ${defaultExport.name}\n`
    } else {
      declaration += `  const ${defaultExport.name}: any\n`
      declaration += `  export default ${defaultExport.name}\n`
    }
  }

  const namedExports = exports.filter(e => !e.isDefault)
  for (const exp of namedExports) {
    declaration += `  export const ${exp.name}: any\n`
  }

  declaration += `}\n`

  return declaration
}

function generateRoutesType(remoteName) {
  return `
declare module '${remoteName}/routes' {
  export interface CashAppsRoute {
    path: string
    title: string
    breadcrumb: string
    component: string
    children?: CashAppsRoute[]
  }

  export const CASHAPPS_BASE_PATH: string
  export const cashappsRoutes: CashAppsRoute[]
  export const cashappsBreadcrumbs: { path: string; title: string }[]
  export const cashappsNavItems: { key: string; label: string }[]
  export function getBreadcrumbsForPath(path: string): { path: string; title: string }[]
}
`
}

function main() {
  console.log('ðŸ”§ Generating remote type declarations...\n')

  let output = `// Auto-generated by scripts/generate-remote-types.js
// Do not edit manually - run: pnpm generate:types

`

  for (const [remoteName, config] of Object.entries(REMOTES_CONFIG)) {
    const configPath = path.join(ROOT, config.configPath)

    if (!fs.existsSync(configPath)) {
      console.log(`Creating federation config for ${remoteName}...`)

      const viteConfigPath = path.join(ROOT, config.srcPath, '../vite.config.ts')
      const viteConfig = fs.readFileSync(viteConfigPath, 'utf-8')

      const exposesMatch = viteConfig.match(/exposes:\s*\{([^}]+)\}/)
      if (exposesMatch) {
        const exposesContent = exposesMatch[1]
        const exposes = {}
        const exposeMatches = exposesContent.matchAll(/'([^']+)':\s*'([^']+)'/g)
        for (const match of exposeMatches) {
          exposes[match[1]] = match[2]
        }

        const federationConfig = { name: remoteName, exposes }
        fs.writeFileSync(configPath, JSON.stringify(federationConfig, null, 2))
        console.log(`Created: ${configPath}`)
      }
    }

    if (fs.existsSync(configPath)) {
      const federationConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'))

      console.log(`Processing ${remoteName}:`)

      for (const [exposeName, exposePath] of Object.entries(federationConfig.exposes)) {
        if (exposeName === './routes') {
          output += generateRoutesType(remoteName)
          console.log(`  âœ“ ${exposeName} (routes manifest)`)
        } else {
          const declaration = generateTypeForExpose(
            remoteName,
            exposeName,
            exposePath,
            config.srcPath
          )
          if (declaration) {
            output += declaration + '\n'
            console.log(`  âœ“ ${exposeName}`)
          }
        }
      }
    }
  }

  const outputPath = path.join(ROOT, OUTPUT_PATH)
  fs.writeFileSync(outputPath, output)
  console.log(`\nâœ… Generated: ${OUTPUT_PATH}`)
}

main()
